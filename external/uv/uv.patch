diff --git a/include/uv.h b/include/uv.h
index 9e450c5..7ff213f 100644
--- a/include/uv.h
+++ b/include/uv.h
@@ -725,6 +725,8 @@ struct uv_udp_s {
    * Number of send requests currently in the queue awaiting to be processed.
    */
   size_t send_queue_count;
+  struct sockaddr_storage peer_name;
+  uint8_t is_tproxy;
   UV_UDP_PRIVATE_FIELDS
 };
 
@@ -747,6 +749,9 @@ UV_EXTERN int uv_udp_connect(uv_udp_t* handle, const struct sockaddr* addr);
 UV_EXTERN int uv_udp_getpeername(const uv_udp_t* handle,
                                  struct sockaddr* name,
                                  int* namelen);
+UV_EXTERN int uv_udp_getpeername_ex(const uv_udp_t* handle,
+                                 struct sockaddr** name,
+                                 int* namelen);
 UV_EXTERN int uv_udp_getsockname(const uv_udp_t* handle,
                                  struct sockaddr* name,
                                  int* namelen);
diff --git a/src/unix/udp.c b/src/unix/udp.c
index f6640fc..fc0eac8 100644
--- a/src/unix/udp.c
+++ b/src/unix/udp.c
@@ -33,41 +33,43 @@
 #include <sys/un.h>
 
 #if defined(IPV6_JOIN_GROUP) && !defined(IPV6_ADD_MEMBERSHIP)
-# define IPV6_ADD_MEMBERSHIP IPV6_JOIN_GROUP
+#define IPV6_ADD_MEMBERSHIP IPV6_JOIN_GROUP
 #endif
 
 #if defined(IPV6_LEAVE_GROUP) && !defined(IPV6_DROP_MEMBERSHIP)
-# define IPV6_DROP_MEMBERSHIP IPV6_LEAVE_GROUP
+#define IPV6_DROP_MEMBERSHIP IPV6_LEAVE_GROUP
 #endif
 
-static void uv__udp_run_completed(uv_udp_t* handle);
-static void uv__udp_io(uv_loop_t* loop, uv__io_t* w, unsigned int revents);
-static void uv__udp_recvmsg(uv_udp_t* handle);
-static void uv__udp_sendmsg(uv_udp_t* handle);
-static int uv__udp_maybe_deferred_bind(uv_udp_t* handle,
+static void uv__udp_run_completed(uv_udp_t *handle);
+static void uv__udp_io(uv_loop_t *loop, uv__io_t *w, unsigned int revents);
+static void uv__udp_recvmsg(uv_udp_t *handle);
+static void uv__udp_sendmsg(uv_udp_t *handle);
+static int uv__udp_maybe_deferred_bind(uv_udp_t *handle,
                                        int domain,
                                        unsigned int flags);
 
-
-void uv__udp_close(uv_udp_t* handle) {
+void uv__udp_close(uv_udp_t *handle)
+{
   uv__io_close(handle->loop, &handle->io_watcher);
   uv__handle_stop(handle);
 
-  if (handle->io_watcher.fd != -1) {
+  if (handle->io_watcher.fd != -1)
+  {
     uv__close(handle->io_watcher.fd);
     handle->io_watcher.fd = -1;
   }
 }
 
-
-void uv__udp_finish_close(uv_udp_t* handle) {
-  uv_udp_send_t* req;
-  struct uv__queue* q;
+void uv__udp_finish_close(uv_udp_t *handle)
+{
+  uv_udp_send_t *req;
+  struct uv__queue *q;
 
   assert(!uv__io_active(&handle->io_watcher, POLLIN | POLLOUT));
   assert(handle->io_watcher.fd == -1);
 
-  while (!uv__queue_empty(&handle->write_queue)) {
+  while (!uv__queue_empty(&handle->write_queue))
+  {
     q = uv__queue_head(&handle->write_queue);
     uv__queue_remove(q);
 
@@ -87,15 +89,16 @@ void uv__udp_finish_close(uv_udp_t* handle) {
   /* but _do not_ touch close_cb */
 }
 
-
-static void uv__udp_run_completed(uv_udp_t* handle) {
-  uv_udp_send_t* req;
-  struct uv__queue* q;
+static void uv__udp_run_completed(uv_udp_t *handle)
+{
+  uv_udp_send_t *req;
+  struct uv__queue *q;
 
   assert(!(handle->flags & UV_HANDLE_UDP_PROCESSING));
   handle->flags |= UV_HANDLE_UDP_PROCESSING;
 
-  while (!uv__queue_empty(&handle->write_completed_queue)) {
+  while (!uv__queue_empty(&handle->write_completed_queue))
+  {
     q = uv__queue_head(&handle->write_completed_queue);
     uv__queue_remove(q);
 
@@ -121,7 +124,8 @@ static void uv__udp_run_completed(uv_udp_t* handle) {
       req->send_cb(req, req->status);
   }
 
-  if (uv__queue_empty(&handle->write_queue)) {
+  if (uv__queue_empty(&handle->write_queue))
+  {
     /* Pending queue and completion queue empty, stop watcher. */
     uv__io_stop(handle->loop, &handle->io_watcher, POLLOUT);
     if (!uv__io_active(&handle->io_watcher, POLLIN))
@@ -131,9 +135,9 @@ static void uv__udp_run_completed(uv_udp_t* handle) {
   handle->flags &= ~UV_HANDLE_UDP_PROCESSING;
 }
 
-
-static void uv__udp_io(uv_loop_t* loop, uv__io_t* w, unsigned int revents) {
-  uv_udp_t* handle;
+static void uv__udp_io(uv_loop_t *loop, uv__io_t *w, unsigned int revents)
+{
+  uv_udp_t *handle;
 
   handle = container_of(w, uv_udp_t, io_watcher);
   assert(handle->type == UV_UDP);
@@ -141,13 +145,15 @@ static void uv__udp_io(uv_loop_t* loop, uv__io_t* w, unsigned int revents) {
   if (revents & POLLIN)
     uv__udp_recvmsg(handle);
 
-  if (revents & POLLOUT && !uv__is_closing(handle)) {
+  if (revents & POLLOUT && !uv__is_closing(handle))
+  {
     uv__udp_sendmsg(handle);
     uv__udp_run_completed(handle);
   }
 }
 
-static int uv__udp_recvmmsg(uv_udp_t* handle, uv_buf_t* buf) {
+static int uv__udp_recvmmsg(uv_udp_t *handle, uv_buf_t *buf)
+{
 #if defined(__linux__) || defined(__FreeBSD__) || defined(__APPLE__)
   struct sockaddr_in6 peers[20];
   struct iovec iov[ARRAY_SIZE(peers)];
@@ -162,7 +168,8 @@ static int uv__udp_recvmmsg(uv_udp_t* handle, uv_buf_t* buf) {
   chunks = buf->len / UV__UDP_DGRAM_MAXSIZE;
   if (chunks > ARRAY_SIZE(iov))
     chunks = ARRAY_SIZE(iov);
-  for (k = 0; k < chunks; ++k) {
+  for (k = 0; k < chunks; ++k)
+  {
     iov[k].iov_base = buf->base + k * UV__UDP_DGRAM_MAXSIZE;
     iov[k].iov_len = UV__UDP_DGRAM_MAXSIZE;
     memset(&msgs[k].msg_hdr, 0, sizeof(msgs[k].msg_hdr));
@@ -186,14 +193,18 @@ static int uv__udp_recvmmsg(uv_udp_t* handle, uv_buf_t* buf) {
   while (nread == -1 && errno == EINTR);
 #endif
 
-  if (nread < 1) {
+  if (nread < 1)
+  {
     if (nread == 0 || errno == EAGAIN || errno == EWOULDBLOCK)
       handle->recv_cb(handle, 0, buf, NULL, 0);
     else
       handle->recv_cb(handle, UV__ERR(errno), buf, NULL, 0);
-  } else {
+  }
+  else
+  {
     /* pass each chunk to the application */
-    for (k = 0; k < (size_t) nread && handle->recv_cb != NULL; k++) {
+    for (k = 0; k < (size_t)nread && handle->recv_cb != NULL; k++)
+    {
       flags = UV_UDP_MMSG_CHUNK;
       if (msgs[k].msg_hdr.msg_flags & MSG_TRUNC)
         flags |= UV_UDP_PARTIAL;
@@ -213,12 +224,35 @@ static int uv__udp_recvmmsg(uv_udp_t* handle, uv_buf_t* buf) {
   return nread;
 #else  /* __linux__ || ____FreeBSD__ || __APPLE__ */
   return UV_ENOSYS;
-#endif  /* __linux__ || ____FreeBSD__ || __APPLE__ */
+#endif /* __linux__ || ____FreeBSD__ || __APPLE__ */
 }
 
-static void uv__udp_recvmsg(uv_udp_t* handle) {
+static int get_dstaddr(struct msghdr *msg, struct sockaddr_storage *dstaddr)
+{
+  struct cmsghdr *cmsg;
+  for (cmsg = CMSG_FIRSTHDR(msg); cmsg; cmsg = CMSG_NXTHDR(msg, cmsg))
+  {
+    if (cmsg->cmsg_level == IPPROTO_IP && cmsg->cmsg_type == IP_RECVORIGDSTADDR)
+    {
+      memcpy(dstaddr, CMSG_DATA(cmsg), sizeof(struct sockaddr_in));
+      dstaddr->ss_family = AF_INET;
+      return 0;
+    }
+    else if (cmsg->cmsg_level == IPPROTO_IPV6 && cmsg->cmsg_type == IPV6_RECVORIGDSTADDR)
+    {
+      memcpy(dstaddr, CMSG_DATA(cmsg), sizeof(struct sockaddr_in6));
+      dstaddr->ss_family = AF_INET6;
+      return 0;
+    }
+  }
+  return 1;
+}
+
+static void uv__udp_recvmsg(uv_udp_t *handle)
+{
   struct sockaddr_storage peer;
   struct msghdr h;
+  char control[CMSG_SPACE(sizeof(struct in_pktinfo))];
   ssize_t nread;
   uv_buf_t buf;
   int flags;
@@ -232,16 +266,19 @@ static void uv__udp_recvmsg(uv_udp_t* handle) {
    */
   count = 32;
 
-  do {
+  do
+  {
     buf = uv_buf_init(NULL, 0);
-    handle->alloc_cb((uv_handle_t*) handle, UV__UDP_DGRAM_MAXSIZE, &buf);
-    if (buf.base == NULL || buf.len == 0) {
+    handle->alloc_cb((uv_handle_t *)handle, UV__UDP_DGRAM_MAXSIZE, &buf);
+    if (buf.base == NULL || buf.len == 0)
+    {
       handle->recv_cb(handle, UV_ENOBUFS, &buf, NULL, 0);
       return;
     }
     assert(buf.base != NULL);
 
-    if (uv_udp_using_recvmmsg(handle)) {
+    if (uv_udp_using_recvmmsg(handle))
+    {
       nread = uv__udp_recvmmsg(handle, &buf);
       if (nread > 0)
         count -= nread;
@@ -252,47 +289,56 @@ static void uv__udp_recvmsg(uv_udp_t* handle) {
     memset(&peer, 0, sizeof(peer));
     h.msg_name = &peer;
     h.msg_namelen = sizeof(peer);
-    h.msg_iov = (void*) &buf;
+    h.msg_iov = (void *)&buf;
     h.msg_iovlen = 1;
+    h.msg_control = control;
+    h.msg_controllen = sizeof(control);
 
-    do {
+    do
+    {
       nread = recvmsg(handle->io_watcher.fd, &h, 0);
-    }
-    while (nread == -1 && errno == EINTR);
+    } while (nread == -1 && errno == EINTR);
 
-    if (nread == -1) {
+    if (nread == -1)
+    {
       if (errno == EAGAIN || errno == EWOULDBLOCK)
         handle->recv_cb(handle, 0, &buf, NULL, 0);
       else
         handle->recv_cb(handle, UV__ERR(errno), &buf, NULL, 0);
     }
-    else {
+    else
+    {
       flags = 0;
       if (h.msg_flags & MSG_TRUNC)
         flags |= UV_UDP_PARTIAL;
-
-      handle->recv_cb(handle, nread, &buf, (const struct sockaddr*) &peer, flags);
+      if (handle->is_tproxy)
+      {
+        get_dstaddr(&h, &handle->peer_name);
+      }
+      handle->recv_cb(handle, nread, &buf, (const struct sockaddr *)&peer, flags);
     }
     count--;
   }
   /* recv_cb callback may decide to pause or close the handle */
-  while (nread != -1
-      && count > 0
-      && handle->io_watcher.fd != -1
-      && handle->recv_cb != NULL);
+  while (nread != -1 && count > 0 && handle->io_watcher.fd != -1 && handle->recv_cb != NULL);
 }
 
-static void uv__udp_sendmsg_one(uv_udp_t* handle, uv_udp_send_t* req) {
-  struct uv__queue* q;
+static void uv__udp_sendmsg_one(uv_udp_t *handle, uv_udp_send_t *req)
+{
+  struct uv__queue *q;
   struct msghdr h;
   ssize_t size;
 
-  for (;;) {
+  for (;;)
+  {
     memset(&h, 0, sizeof h);
-    if (req->addr.ss_family == AF_UNSPEC) {
+    if (req->addr.ss_family == AF_UNSPEC)
+    {
       h.msg_name = NULL;
       h.msg_namelen = 0;
-    } else {
+    }
+    else
+    {
       h.msg_name = &req->addr;
       if (req->addr.ss_family == AF_INET6)
         h.msg_namelen = sizeof(struct sockaddr_in6);
@@ -300,12 +346,13 @@ static void uv__udp_sendmsg_one(uv_udp_t* handle, uv_udp_send_t* req) {
         h.msg_namelen = sizeof(struct sockaddr_in);
       else if (req->addr.ss_family == AF_UNIX)
         h.msg_namelen = sizeof(struct sockaddr_un);
-      else {
+      else
+      {
         assert(0 && "unsupported address family");
         abort();
       }
     }
-    h.msg_iov = (struct iovec*) req->bufs;
+    h.msg_iov = (struct iovec *)req->bufs;
     h.msg_iovlen = req->nbufs;
 
     do
@@ -336,11 +383,12 @@ static void uv__udp_sendmsg_one(uv_udp_t* handle, uv_udp_send_t* req) {
 }
 
 #if defined(__linux__) || defined(__FreeBSD__) || defined(__APPLE__)
-static void uv__udp_sendmsg_many(uv_udp_t* handle) {
-  uv_udp_send_t* req;
+static void uv__udp_sendmsg_many(uv_udp_t *handle)
+{
+  uv_udp_send_t *req;
   struct mmsghdr h[20];
-  struct mmsghdr* p;
-  struct uv__queue* q;
+  struct mmsghdr *p;
+  struct uv__queue *q;
   ssize_t npkts;
   size_t pkts;
   size_t i;
@@ -348,15 +396,19 @@ static void uv__udp_sendmsg_many(uv_udp_t* handle) {
 write_queue_drain:
   for (pkts = 0, q = uv__queue_head(&handle->write_queue);
        pkts < ARRAY_SIZE(h) && q != &handle->write_queue;
-       ++pkts, q = uv__queue_head(q)) {
+       ++pkts, q = uv__queue_head(q))
+  {
     req = uv__queue_data(q, uv_udp_send_t, queue);
 
     p = &h[pkts];
     memset(p, 0, sizeof(*p));
-    if (req->addr.ss_family == AF_UNSPEC) {
+    if (req->addr.ss_family == AF_UNSPEC)
+    {
       p->msg_hdr.msg_name = NULL;
       p->msg_hdr.msg_namelen = 0;
-    } else {
+    }
+    else
+    {
       p->msg_hdr.msg_name = &req->addr;
       if (req->addr.ss_family == AF_INET6)
         p->msg_hdr.msg_namelen = sizeof(struct sockaddr_in6);
@@ -364,12 +416,13 @@ write_queue_drain:
         p->msg_hdr.msg_namelen = sizeof(struct sockaddr_in);
       else if (req->addr.ss_family == AF_UNIX)
         p->msg_hdr.msg_namelen = sizeof(struct sockaddr_un);
-      else {
+      else
+      {
         assert(0 && "unsupported address family");
         abort();
       }
     }
-    h[pkts].msg_hdr.msg_iov = (struct iovec*) req->bufs;
+    h[pkts].msg_hdr.msg_iov = (struct iovec *)req->bufs;
     h[pkts].msg_hdr.msg_iovlen = req->nbufs;
   }
 
@@ -383,12 +436,14 @@ write_queue_drain:
   while (npkts == -1 && errno == EINTR);
 #endif
 
-  if (npkts < 1) {
+  if (npkts < 1)
+  {
     if (errno == EAGAIN || errno == EWOULDBLOCK || errno == ENOBUFS)
       return;
     for (i = 0, q = uv__queue_head(&handle->write_queue);
          i < pkts && q != &handle->write_queue;
-         ++i, q = uv__queue_head(&handle->write_queue)) {
+         ++i, q = uv__queue_head(&handle->write_queue))
+    {
       req = uv__queue_data(q, uv_udp_send_t, queue);
       req->status = UV__ERR(errno);
       uv__queue_remove(&req->queue);
@@ -403,7 +458,8 @@ write_queue_drain:
    */
   for (i = 0, q = uv__queue_head(&handle->write_queue);
        i < (size_t)npkts && q != &handle->write_queue;
-       ++i, q = uv__queue_head(&handle->write_queue)) {
+       ++i, q = uv__queue_head(&handle->write_queue))
+  {
     req = uv__queue_data(q, uv_udp_send_t, queue);
     req->status = req->bufs[0].len;
 
@@ -422,11 +478,12 @@ write_queue_drain:
 
   uv__io_feed(handle->loop, &handle->io_watcher);
 }
-#endif  /* __linux__ || ____FreeBSD__ || __APPLE__ */
+#endif /* __linux__ || ____FreeBSD__ || __APPLE__ */
 
-static void uv__udp_sendmsg(uv_udp_t* handle) {
-  struct uv__queue* q;
-  uv_udp_send_t* req;
+static void uv__udp_sendmsg(uv_udp_t *handle)
+{
+  struct uv__queue *q;
+  uv_udp_send_t *req;
 
   if (uv__queue_empty(&handle->write_queue))
     return;
@@ -460,24 +517,28 @@ static void uv__udp_sendmsg(uv_udp_t* handle) {
  * zOS does not support getsockname with SO_REUSEPORT option when using
  * AF_UNIX.
  */
-static int uv__sock_reuseaddr(int fd) {
+static int uv__sock_reuseaddr(int fd)
+{
   int yes;
   yes = 1;
 
 #if defined(SO_REUSEPORT) && defined(__MVS__)
   struct sockaddr_in sockfd;
   unsigned int sockfd_len = sizeof(sockfd);
-  if (getsockname(fd, (struct sockaddr*) &sockfd, &sockfd_len) == -1)
-      return UV__ERR(errno);
-  if (sockfd.sin_family == AF_UNIX) {
+  if (getsockname(fd, (struct sockaddr *)&sockfd, &sockfd_len) == -1)
+    return UV__ERR(errno);
+  if (sockfd.sin_family == AF_UNIX)
+  {
     if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes)))
       return UV__ERR(errno);
-  } else {
+  }
+  else
+  {
     if (setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &yes, sizeof(yes)))
-       return UV__ERR(errno);
+      return UV__ERR(errno);
   }
 #elif defined(SO_REUSEPORT) && !defined(__linux__) && !defined(__GNU__) && \
-	!defined(__sun__) && !defined(__DragonFly__) && !defined(_AIX73)
+    !defined(__sun__) && !defined(__DragonFly__) && !defined(_AIX73)
   if (setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &yes, sizeof(yes)))
     return UV__ERR(errno);
 #else
@@ -494,27 +555,31 @@ static int uv__sock_reuseaddr(int fd) {
  * error reporting, hopefully resulting in faster failover to working name
  * servers.
  */
-static int uv__set_recverr(int fd, sa_family_t ss_family) {
+static int uv__set_recverr(int fd, sa_family_t ss_family)
+{
 #if defined(__linux__)
   int yes;
 
   yes = 1;
-  if (ss_family == AF_INET) {
+  if (ss_family == AF_INET)
+  {
     if (setsockopt(fd, IPPROTO_IP, IP_RECVERR, &yes, sizeof(yes)))
       return UV__ERR(errno);
-  } else if (ss_family == AF_INET6) {
+  }
+  else if (ss_family == AF_INET6)
+  {
     if (setsockopt(fd, IPPROTO_IPV6, IPV6_RECVERR, &yes, sizeof(yes)))
-       return UV__ERR(errno);
+      return UV__ERR(errno);
   }
 #endif
   return 0;
 }
 
-
-int uv__udp_bind(uv_udp_t* handle,
-                 const struct sockaddr* addr,
+int uv__udp_bind(uv_udp_t *handle,
+                 const struct sockaddr *addr,
                  unsigned int addrlen,
-                 unsigned int flags) {
+                 unsigned int flags)
+{
   int err;
   int yes;
   int fd;
@@ -529,7 +594,8 @@ int uv__udp_bind(uv_udp_t* handle,
     return UV_EINVAL;
 
   fd = handle->io_watcher.fd;
-  if (fd == -1) {
+  if (fd == -1)
+  {
     err = uv__socket(addr->sa_family, SOCK_DGRAM, 0);
     if (err < 0)
       return err;
@@ -537,28 +603,33 @@ int uv__udp_bind(uv_udp_t* handle,
     handle->io_watcher.fd = fd;
   }
 
-  if (flags & UV_UDP_LINUX_RECVERR) {
+  if (flags & UV_UDP_LINUX_RECVERR)
+  {
     err = uv__set_recverr(fd, addr->sa_family);
     if (err)
       return err;
   }
 
-  if (flags & UV_UDP_REUSEADDR) {
+  if (flags & UV_UDP_REUSEADDR)
+  {
     err = uv__sock_reuseaddr(fd);
     if (err)
       return err;
   }
 
-  if (flags & UV_UDP_REUSEPORT) {
+  if (flags & UV_UDP_REUSEPORT)
+  {
     err = uv__sock_reuseport(fd);
     if (err)
       return err;
   }
 
-  if (flags & UV_UDP_IPV6ONLY) {
+  if (flags & UV_UDP_IPV6ONLY)
+  {
 #ifdef IPV6_V6ONLY
     yes = 1;
-    if (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &yes, sizeof yes) == -1) {
+    if (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &yes, sizeof yes) == -1)
+    {
       err = UV__ERR(errno);
       return err;
     }
@@ -568,7 +639,8 @@ int uv__udp_bind(uv_udp_t* handle,
 #endif
   }
 
-  if (bind(fd, addr, addrlen)) {
+  if (bind(fd, addr, addrlen))
+  {
     err = UV__ERR(errno);
     if (errno == EAFNOSUPPORT)
       /* OSX, other BSDs and SunoS fail with EAFNOSUPPORT when binding a
@@ -584,20 +656,21 @@ int uv__udp_bind(uv_udp_t* handle,
   return 0;
 }
 
-
-static int uv__udp_maybe_deferred_bind(uv_udp_t* handle,
+static int uv__udp_maybe_deferred_bind(uv_udp_t *handle,
                                        int domain,
-                                       unsigned int flags) {
+                                       unsigned int flags)
+{
   union uv__sockaddr taddr;
   socklen_t addrlen;
 
   if (handle->io_watcher.fd != -1)
     return 0;
 
-  switch (domain) {
+  switch (domain)
+  {
   case AF_INET:
   {
-    struct sockaddr_in* addr = &taddr.in;
+    struct sockaddr_in *addr = &taddr.in;
     memset(addr, 0, sizeof *addr);
     addr->sin_family = AF_INET;
     addr->sin_addr.s_addr = INADDR_ANY;
@@ -606,7 +679,7 @@ static int uv__udp_maybe_deferred_bind(uv_udp_t* handle,
   }
   case AF_INET6:
   {
-    struct sockaddr_in6* addr = &taddr.in6;
+    struct sockaddr_in6 *addr = &taddr.in6;
     memset(addr, 0, sizeof *addr);
     addr->sin6_family = AF_INET6;
     addr->sin6_addr = in6addr_any;
@@ -621,17 +694,18 @@ static int uv__udp_maybe_deferred_bind(uv_udp_t* handle,
   return uv__udp_bind(handle, &taddr.addr, addrlen, flags);
 }
 
-
-int uv__udp_connect(uv_udp_t* handle,
-                    const struct sockaddr* addr,
-                    unsigned int addrlen) {
+int uv__udp_connect(uv_udp_t *handle,
+                    const struct sockaddr *addr,
+                    unsigned int addrlen)
+{
   int err;
 
   err = uv__udp_maybe_deferred_bind(handle, addr->sa_family, 0);
   if (err)
     return err;
 
-  do {
+  do
+  {
     errno = 0;
     err = connect(handle->io_watcher.fd, addr, addrlen);
   } while (err == -1 && errno == EINTR);
@@ -675,62 +749,67 @@ int uv__udp_connect(uv_udp_t* handle,
  *   if(addr->sa_len < sizeof(struct sockaddr)) return EINVAL;
  *   if (addr->sa_family == AF_UNSPEC) sodisconnect(so);
  */
-int uv__udp_disconnect(uv_udp_t* handle) {
-    int r;
+int uv__udp_disconnect(uv_udp_t *handle)
+{
+  int r;
 #if defined(__MVS__)
-    struct sockaddr_storage addr;
+  struct sockaddr_storage addr;
 #else
-    struct sockaddr addr;
+  struct sockaddr addr;
 #endif
 
-    memset(&addr, 0, sizeof(addr));
+  memset(&addr, 0, sizeof(addr));
 
 #if defined(__MVS__)
-    addr.ss_family = AF_UNSPEC;
+  addr.ss_family = AF_UNSPEC;
 #else
-    addr.sa_family = AF_UNSPEC;
+  addr.sa_family = AF_UNSPEC;
 #endif
 
-    do {
-      errno = 0;
+  do
+  {
+    errno = 0;
 #ifdef __PASE__
-      /* On IBMi a connectionless transport socket can be disconnected by
-       * either setting the addr parameter to NULL or setting the
-       * addr_length parameter to zero, and issuing another connect().
-       * https://www.ibm.com/docs/en/i/7.4?topic=ssw_ibm_i_74/apis/connec.htm
-       */
-      r = connect(handle->io_watcher.fd, (struct sockaddr*) NULL, 0);
+    /* On IBMi a connectionless transport socket can be disconnected by
+     * either setting the addr parameter to NULL or setting the
+     * addr_length parameter to zero, and issuing another connect().
+     * https://www.ibm.com/docs/en/i/7.4?topic=ssw_ibm_i_74/apis/connec.htm
+     */
+    r = connect(handle->io_watcher.fd, (struct sockaddr *)NULL, 0);
 #else
-      r = connect(handle->io_watcher.fd, (struct sockaddr*) &addr, sizeof(addr));
+    r = connect(handle->io_watcher.fd, (struct sockaddr *)&addr, sizeof(addr));
 #endif
-    } while (r == -1 && errno == EINTR);
+  } while (r == -1 && errno == EINTR);
 
-    if (r == -1) {
-#if defined(BSD)  /* The macro BSD is from sys/param.h */
-      if (errno != EAFNOSUPPORT && errno != EINVAL)
-        return UV__ERR(errno);
-#else
+  if (r == -1)
+  {
+#if defined(BSD) /* The macro BSD is from sys/param.h */
+    if (errno != EAFNOSUPPORT && errno != EINVAL)
       return UV__ERR(errno);
+#else
+    return UV__ERR(errno);
 #endif
-    }
+  }
 
-    handle->flags &= ~UV_HANDLE_UDP_CONNECTED;
-    return 0;
+  handle->flags &= ~UV_HANDLE_UDP_CONNECTED;
+  return 0;
 }
 
-int uv__udp_send(uv_udp_send_t* req,
-                 uv_udp_t* handle,
+int uv__udp_send(uv_udp_send_t *req,
+                 uv_udp_t *handle,
                  const uv_buf_t bufs[],
                  unsigned int nbufs,
-                 const struct sockaddr* addr,
+                 const struct sockaddr *addr,
                  unsigned int addrlen,
-                 uv_udp_send_cb send_cb) {
+                 uv_udp_send_cb send_cb)
+{
   int err;
   int empty_queue;
 
   assert(nbufs > 0);
 
-  if (addr) {
+  if (addr)
+  {
     err = uv__udp_maybe_deferred_bind(handle, addr->sa_family, 0);
     if (err)
       return err;
@@ -756,7 +835,8 @@ int uv__udp_send(uv_udp_send_t* req,
   if (nbufs > ARRAY_SIZE(req->bufsml))
     req->bufs = uv__malloc(nbufs * sizeof(bufs[0]));
 
-  if (req->bufs == NULL) {
+  if (req->bufs == NULL)
+  {
     uv__req_unregister(handle->loop);
     return UV_ENOMEM;
   }
@@ -767,7 +847,8 @@ int uv__udp_send(uv_udp_send_t* req,
   uv__queue_insert_tail(&handle->write_queue, &req->queue);
   uv__handle_start(handle);
 
-  if (empty_queue && !(handle->flags & UV_HANDLE_UDP_PROCESSING)) {
+  if (empty_queue && !(handle->flags & UV_HANDLE_UDP_PROCESSING))
+  {
     uv__udp_sendmsg(handle);
 
     /* `uv__udp_sendmsg` may not be able to do non-blocking write straight
@@ -776,19 +857,21 @@ int uv__udp_send(uv_udp_send_t* req,
      */
     if (!uv__queue_empty(&handle->write_queue))
       uv__io_start(handle->loop, &handle->io_watcher, POLLOUT);
-  } else {
+  }
+  else
+  {
     uv__io_start(handle->loop, &handle->io_watcher, POLLOUT);
   }
 
   return 0;
 }
 
-
-int uv__udp_try_send(uv_udp_t* handle,
+int uv__udp_try_send(uv_udp_t *handle,
                      const uv_buf_t bufs[],
                      unsigned int nbufs,
-                     const struct sockaddr* addr,
-                     unsigned int addrlen) {
+                     const struct sockaddr *addr,
+                     unsigned int addrlen)
+{
   int err;
   struct msghdr h;
   ssize_t size;
@@ -799,25 +882,30 @@ int uv__udp_try_send(uv_udp_t* handle,
   if (handle->send_queue_count != 0)
     return UV_EAGAIN;
 
-  if (addr) {
+  if (addr)
+  {
     err = uv__udp_maybe_deferred_bind(handle, addr->sa_family, 0);
     if (err)
       return err;
-  } else {
+  }
+  else
+  {
     assert(handle->flags & UV_HANDLE_UDP_CONNECTED);
   }
 
   memset(&h, 0, sizeof h);
-  h.msg_name = (struct sockaddr*) addr;
+  h.msg_name = (struct sockaddr *)addr;
   h.msg_namelen = addrlen;
-  h.msg_iov = (struct iovec*) bufs;
+  h.msg_iov = (struct iovec *)bufs;
   h.msg_iovlen = nbufs;
 
-  do {
+  do
+  {
     size = sendmsg(handle->io_watcher.fd, &h, 0);
   } while (size == -1 && errno == EINTR);
 
-  if (size == -1) {
+  if (size == -1)
+  {
     if (errno == EAGAIN || errno == EWOULDBLOCK || errno == ENOBUFS)
       return UV_EAGAIN;
     else
@@ -827,28 +915,32 @@ int uv__udp_try_send(uv_udp_t* handle,
   return size;
 }
 
-
-static int uv__udp_set_membership4(uv_udp_t* handle,
-                                   const struct sockaddr_in* multicast_addr,
-                                   const char* interface_addr,
-                                   uv_membership membership) {
+static int uv__udp_set_membership4(uv_udp_t *handle,
+                                   const struct sockaddr_in *multicast_addr,
+                                   const char *interface_addr,
+                                   uv_membership membership)
+{
   struct ip_mreq mreq;
   int optname;
   int err;
 
   memset(&mreq, 0, sizeof mreq);
 
-  if (interface_addr) {
+  if (interface_addr)
+  {
     err = uv_inet_pton(AF_INET, interface_addr, &mreq.imr_interface.s_addr);
     if (err)
       return err;
-  } else {
+  }
+  else
+  {
     mreq.imr_interface.s_addr = htonl(INADDR_ANY);
   }
 
   mreq.imr_multiaddr.s_addr = multicast_addr->sin_addr.s_addr;
 
-  switch (membership) {
+  switch (membership)
+  {
   case UV_JOIN_GROUP:
     optname = IP_ADD_MEMBERSHIP;
     break;
@@ -863,10 +955,11 @@ static int uv__udp_set_membership4(uv_udp_t* handle,
                  IPPROTO_IP,
                  optname,
                  &mreq,
-                 sizeof(mreq))) {
+                 sizeof(mreq)))
+  {
 #if defined(__MVS__)
-  if (errno == ENXIO)
-    return UV_ENODEV;
+    if (errno == ENXIO)
+      return UV_ENODEV;
 #endif
     return UV__ERR(errno);
   }
@@ -874,28 +967,32 @@ static int uv__udp_set_membership4(uv_udp_t* handle,
   return 0;
 }
 
-
-static int uv__udp_set_membership6(uv_udp_t* handle,
-                                   const struct sockaddr_in6* multicast_addr,
-                                   const char* interface_addr,
-                                   uv_membership membership) {
+static int uv__udp_set_membership6(uv_udp_t *handle,
+                                   const struct sockaddr_in6 *multicast_addr,
+                                   const char *interface_addr,
+                                   uv_membership membership)
+{
   int optname;
   struct ipv6_mreq mreq;
   struct sockaddr_in6 addr6;
 
   memset(&mreq, 0, sizeof mreq);
 
-  if (interface_addr) {
+  if (interface_addr)
+  {
     if (uv_ip6_addr(interface_addr, 0, &addr6))
       return UV_EINVAL;
     mreq.ipv6mr_interface = addr6.sin6_scope_id;
-  } else {
+  }
+  else
+  {
     mreq.ipv6mr_interface = 0;
   }
 
   mreq.ipv6mr_multiaddr = multicast_addr->sin6_addr;
 
-  switch (membership) {
+  switch (membership)
+  {
   case UV_JOIN_GROUP:
     optname = IPV6_ADD_MEMBERSHIP;
     break;
@@ -910,10 +1007,11 @@ static int uv__udp_set_membership6(uv_udp_t* handle,
                  IPPROTO_IPV6,
                  optname,
                  &mreq,
-                 sizeof(mreq))) {
+                 sizeof(mreq)))
+  {
 #if defined(__MVS__)
-  if (errno == ENXIO)
-    return UV_ENODEV;
+    if (errno == ENXIO)
+      return UV_ENODEV;
 #endif
     return UV__ERR(errno);
   }
@@ -921,18 +1019,18 @@ static int uv__udp_set_membership6(uv_udp_t* handle,
   return 0;
 }
 
-
-#if !defined(__OpenBSD__) &&                                        \
-    !defined(__NetBSD__) &&                                         \
-    !defined(__ANDROID__) &&                                        \
-    !defined(__DragonFly__) &&                                      \
-    !defined(__QNX__) &&                                            \
+#if !defined(__OpenBSD__) &&   \
+    !defined(__NetBSD__) &&    \
+    !defined(__ANDROID__) &&   \
+    !defined(__DragonFly__) && \
+    !defined(__QNX__) &&       \
     !defined(__GNU__)
-static int uv__udp_set_source_membership4(uv_udp_t* handle,
-                                          const struct sockaddr_in* multicast_addr,
-                                          const char* interface_addr,
-                                          const struct sockaddr_in* source_addr,
-                                          uv_membership membership) {
+static int uv__udp_set_source_membership4(uv_udp_t *handle,
+                                          const struct sockaddr_in *multicast_addr,
+                                          const char *interface_addr,
+                                          const struct sockaddr_in *source_addr,
+                                          uv_membership membership)
+{
   struct ip_mreq_source mreq;
   int optname;
   int err;
@@ -943,11 +1041,14 @@ static int uv__udp_set_source_membership4(uv_udp_t* handle,
 
   memset(&mreq, 0, sizeof(mreq));
 
-  if (interface_addr != NULL) {
+  if (interface_addr != NULL)
+  {
     err = uv_inet_pton(AF_INET, interface_addr, &mreq.imr_interface.s_addr);
     if (err)
       return err;
-  } else {
+  }
+  else
+  {
     mreq.imr_interface.s_addr = htonl(INADDR_ANY);
   }
 
@@ -965,19 +1066,20 @@ static int uv__udp_set_source_membership4(uv_udp_t* handle,
                  IPPROTO_IP,
                  optname,
                  &mreq,
-                 sizeof(mreq))) {
+                 sizeof(mreq)))
+  {
     return UV__ERR(errno);
   }
 
   return 0;
 }
 
-
-static int uv__udp_set_source_membership6(uv_udp_t* handle,
-                                          const struct sockaddr_in6* multicast_addr,
-                                          const char* interface_addr,
-                                          const struct sockaddr_in6* source_addr,
-                                          uv_membership membership) {
+static int uv__udp_set_source_membership6(uv_udp_t *handle,
+                                          const struct sockaddr_in6 *multicast_addr,
+                                          const char *interface_addr,
+                                          const struct sockaddr_in6 *source_addr,
+                                          uv_membership membership)
+{
   struct group_source_req mreq;
   struct sockaddr_in6 addr6;
   int optname;
@@ -989,12 +1091,15 @@ static int uv__udp_set_source_membership6(uv_udp_t* handle,
 
   memset(&mreq, 0, sizeof(mreq));
 
-  if (interface_addr != NULL) {
+  if (interface_addr != NULL)
+  {
     err = uv_ip6_addr(interface_addr, 0, &addr6);
     if (err)
       return err;
     mreq.gsr_interface = addr6.sin6_scope_id;
-  } else {
+  }
+  else
+  {
     mreq.gsr_interface = 0;
   }
 
@@ -1014,7 +1119,8 @@ static int uv__udp_set_source_membership6(uv_udp_t* handle,
                  IPPROTO_IPV6,
                  optname,
                  &mreq,
-                 sizeof(mreq))) {
+                 sizeof(mreq)))
+  {
     return UV__ERR(errno);
   }
 
@@ -1022,21 +1128,22 @@ static int uv__udp_set_source_membership6(uv_udp_t* handle,
 }
 #endif
 
-
-int uv__udp_init_ex(uv_loop_t* loop,
-                    uv_udp_t* handle,
+int uv__udp_init_ex(uv_loop_t *loop,
+                    uv_udp_t *handle,
                     unsigned flags,
-                    int domain) {
+                    int domain)
+{
   int fd;
 
   fd = -1;
-  if (domain != AF_UNSPEC) {
+  if (domain != AF_UNSPEC)
+  {
     fd = uv__socket(domain, SOCK_DGRAM, 0);
     if (fd < 0)
       return fd;
   }
 
-  uv__handle_init(loop, (uv_handle_t*)handle, UV_UDP);
+  uv__handle_init(loop, (uv_handle_t *)handle, UV_UDP);
   handle->alloc_cb = NULL;
   handle->recv_cb = NULL;
   handle->send_queue_size = 0;
@@ -1048,8 +1155,8 @@ int uv__udp_init_ex(uv_loop_t* loop,
   return 0;
 }
 
-
-int uv_udp_using_recvmmsg(const uv_udp_t* handle) {
+int uv_udp_using_recvmmsg(const uv_udp_t *handle)
+{
 #if defined(__linux__) || defined(__FreeBSD__) || defined(__APPLE__)
   if (handle->flags & UV_HANDLE_UDP_RECVMMSG)
     return 1;
@@ -1057,8 +1164,8 @@ int uv_udp_using_recvmmsg(const uv_udp_t* handle) {
   return 0;
 }
 
-
-int uv_udp_open(uv_udp_t* handle, uv_os_sock_t sock) {
+int uv_udp_open(uv_udp_t *handle, uv_os_sock_t sock)
+{
   int err;
 
   /* Check for already active socket. */
@@ -1083,48 +1190,54 @@ int uv_udp_open(uv_udp_t* handle, uv_os_sock_t sock) {
   return 0;
 }
 
-
-int uv_udp_set_membership(uv_udp_t* handle,
-                          const char* multicast_addr,
-                          const char* interface_addr,
-                          uv_membership membership) {
+int uv_udp_set_membership(uv_udp_t *handle,
+                          const char *multicast_addr,
+                          const char *interface_addr,
+                          uv_membership membership)
+{
   int err;
   struct sockaddr_in addr4;
   struct sockaddr_in6 addr6;
 
-  if (uv_ip4_addr(multicast_addr, 0, &addr4) == 0) {
+  if (uv_ip4_addr(multicast_addr, 0, &addr4) == 0)
+  {
     err = uv__udp_maybe_deferred_bind(handle, AF_INET, UV_UDP_REUSEADDR);
     if (err)
       return err;
     return uv__udp_set_membership4(handle, &addr4, interface_addr, membership);
-  } else if (uv_ip6_addr(multicast_addr, 0, &addr6) == 0) {
+  }
+  else if (uv_ip6_addr(multicast_addr, 0, &addr6) == 0)
+  {
     err = uv__udp_maybe_deferred_bind(handle, AF_INET6, UV_UDP_REUSEADDR);
     if (err)
       return err;
     return uv__udp_set_membership6(handle, &addr6, interface_addr, membership);
-  } else {
+  }
+  else
+  {
     return UV_EINVAL;
   }
 }
 
-
-int uv_udp_set_source_membership(uv_udp_t* handle,
-                                 const char* multicast_addr,
-                                 const char* interface_addr,
-                                 const char* source_addr,
-                                 uv_membership membership) {
-#if !defined(__OpenBSD__) &&                                        \
-    !defined(__NetBSD__) &&                                         \
-    !defined(__ANDROID__) &&                                        \
-    !defined(__DragonFly__) &&                                      \
-    !defined(__QNX__) &&                                            \
+int uv_udp_set_source_membership(uv_udp_t *handle,
+                                 const char *multicast_addr,
+                                 const char *interface_addr,
+                                 const char *source_addr,
+                                 uv_membership membership)
+{
+#if !defined(__OpenBSD__) &&   \
+    !defined(__NetBSD__) &&    \
+    !defined(__ANDROID__) &&   \
+    !defined(__DragonFly__) && \
+    !defined(__QNX__) &&       \
     !defined(__GNU__)
   int err;
   union uv__sockaddr mcast_addr;
   union uv__sockaddr src_addr;
 
   err = uv_ip4_addr(multicast_addr, 0, &mcast_addr.in);
-  if (err) {
+  if (err)
+  {
     err = uv_ip6_addr(multicast_addr, 0, &mcast_addr.in6);
     if (err)
       return err;
@@ -1151,12 +1264,12 @@ int uv_udp_set_source_membership(uv_udp_t* handle,
 #endif
 }
 
-
-static int uv__setsockopt(uv_udp_t* handle,
-                         int option4,
-                         int option6,
-                         const void* val,
-                         socklen_t size) {
+static int uv__setsockopt(uv_udp_t *handle,
+                          int option4,
+                          int option6,
+                          const void *val,
+                          socklen_t size)
+{
   int r;
 
   if (handle->flags & UV_HANDLE_IPV6)
@@ -1177,10 +1290,11 @@ static int uv__setsockopt(uv_udp_t* handle,
   return 0;
 }
 
-static int uv__setsockopt_maybe_char(uv_udp_t* handle,
+static int uv__setsockopt_maybe_char(uv_udp_t *handle,
                                      int option4,
                                      int option6,
-                                     int val) {
+                                     int val)
+{
 #if defined(__sun) || defined(_AIX) || defined(__MVS__)
   char arg = val;
 #elif defined(__OpenBSD__)
@@ -1195,27 +1309,28 @@ static int uv__setsockopt_maybe_char(uv_udp_t* handle,
   return uv__setsockopt(handle, option4, option6, &arg, sizeof(arg));
 }
 
-
-int uv_udp_set_broadcast(uv_udp_t* handle, int on) {
+int uv_udp_set_broadcast(uv_udp_t *handle, int on)
+{
   if (setsockopt(handle->io_watcher.fd,
                  SOL_SOCKET,
                  SO_BROADCAST,
                  &on,
-                 sizeof(on))) {
+                 sizeof(on)))
+  {
     return UV__ERR(errno);
   }
 
   return 0;
 }
 
-
-int uv_udp_set_ttl(uv_udp_t* handle, int ttl) {
+int uv_udp_set_ttl(uv_udp_t *handle, int ttl)
+{
   if (ttl < 1 || ttl > 255)
     return UV_EINVAL;
 
 #if defined(__MVS__)
   if (!(handle->flags & UV_HANDLE_IPV6))
-    return UV_ENOTSUP;  /* zOS does not support setting ttl for IPv4 */
+    return UV_ENOTSUP; /* zOS does not support setting ttl for IPv4 */
 #endif
 
 /*
@@ -1233,7 +1348,7 @@ int uv_udp_set_ttl(uv_udp_t* handle, int ttl) {
                         &ttl,
                         sizeof(ttl));
 
-#else /* !(defined(__sun) || defined(_AIX) || defined (__OpenBSD__) ||
+#else /* !(defined(__sun) || defined(_AIX) || defined (__OpenBSD__) || \
            defined(__MVS__) || defined(__QNX__)) */
 
   return uv__setsockopt_maybe_char(handle,
@@ -1241,12 +1356,12 @@ int uv_udp_set_ttl(uv_udp_t* handle, int ttl) {
                                    IPV6_UNICAST_HOPS,
                                    ttl);
 
-#endif /* defined(__sun) || defined(_AIX) || defined (__OpenBSD__) ||
+#endif /* defined(__sun) || defined(_AIX) || defined (__OpenBSD__) || \
           defined(__MVS__) || defined(__QNX__) */
 }
 
-
-int uv_udp_set_multicast_ttl(uv_udp_t* handle, int ttl) {
+int uv_udp_set_multicast_ttl(uv_udp_t *handle, int ttl)
+{
 /*
  * On Solaris and derivatives such as SmartOS, the length of socket options
  * is sizeof(int) for IPV6_MULTICAST_HOPS and sizeof(char) for
@@ -1270,8 +1385,8 @@ int uv_udp_set_multicast_ttl(uv_udp_t* handle, int ttl) {
                                    ttl);
 }
 
-
-int uv_udp_set_multicast_loop(uv_udp_t* handle, int on) {
+int uv_udp_set_multicast_loop(uv_udp_t *handle, int on)
+{
 /*
  * On Solaris and derivatives such as SmartOS, the length of socket options
  * is sizeof(int) for IPV6_MULTICAST_LOOP and sizeof(char) for
@@ -1286,7 +1401,7 @@ int uv_udp_set_multicast_loop(uv_udp_t* handle, int on) {
                           IPV6_MULTICAST_LOOP,
                           &on,
                           sizeof(on));
-#endif /* defined(__sun) || defined(_AIX) ||defined(__OpenBSD__) ||
+#endif /* defined(__sun) || defined(_AIX) ||defined(__OpenBSD__) || \
     defined(__MVS__) || defined(__QNX__) */
 
   return uv__setsockopt_maybe_char(handle,
@@ -1295,48 +1410,66 @@ int uv_udp_set_multicast_loop(uv_udp_t* handle, int on) {
                                    on);
 }
 
-int uv_udp_set_multicast_interface(uv_udp_t* handle, const char* interface_addr) {
+int uv_udp_set_multicast_interface(uv_udp_t *handle, const char *interface_addr)
+{
   struct sockaddr_storage addr_st;
-  struct sockaddr_in* addr4;
-  struct sockaddr_in6* addr6;
+  struct sockaddr_in *addr4;
+  struct sockaddr_in6 *addr6;
 
-  addr4 = (struct sockaddr_in*) &addr_st;
-  addr6 = (struct sockaddr_in6*) &addr_st;
+  addr4 = (struct sockaddr_in *)&addr_st;
+  addr6 = (struct sockaddr_in6 *)&addr_st;
 
-  if (!interface_addr) {
+  if (!interface_addr)
+  {
     memset(&addr_st, 0, sizeof addr_st);
-    if (handle->flags & UV_HANDLE_IPV6) {
+    if (handle->flags & UV_HANDLE_IPV6)
+    {
       addr_st.ss_family = AF_INET6;
       addr6->sin6_scope_id = 0;
-    } else {
+    }
+    else
+    {
       addr_st.ss_family = AF_INET;
       addr4->sin_addr.s_addr = htonl(INADDR_ANY);
     }
-  } else if (uv_ip4_addr(interface_addr, 0, addr4) == 0) {
+  }
+  else if (uv_ip4_addr(interface_addr, 0, addr4) == 0)
+  {
     /* nothing, address was parsed */
-  } else if (uv_ip6_addr(interface_addr, 0, addr6) == 0) {
+  }
+  else if (uv_ip6_addr(interface_addr, 0, addr6) == 0)
+  {
     /* nothing, address was parsed */
-  } else {
+  }
+  else
+  {
     return UV_EINVAL;
   }
 
-  if (addr_st.ss_family == AF_INET) {
+  if (addr_st.ss_family == AF_INET)
+  {
     if (setsockopt(handle->io_watcher.fd,
                    IPPROTO_IP,
                    IP_MULTICAST_IF,
-                   (void*) &addr4->sin_addr,
-                   sizeof(addr4->sin_addr)) == -1) {
+                   (void *)&addr4->sin_addr,
+                   sizeof(addr4->sin_addr)) == -1)
+    {
       return UV__ERR(errno);
     }
-  } else if (addr_st.ss_family == AF_INET6) {
+  }
+  else if (addr_st.ss_family == AF_INET6)
+  {
     if (setsockopt(handle->io_watcher.fd,
                    IPPROTO_IPV6,
                    IPV6_MULTICAST_IF,
                    &addr6->sin6_scope_id,
-                   sizeof(addr6->sin6_scope_id)) == -1) {
+                   sizeof(addr6->sin6_scope_id)) == -1)
+    {
       return UV__ERR(errno);
     }
-  } else {
+  }
+  else
+  {
     assert(0 && "unexpected address family");
     abort();
   }
@@ -1344,37 +1477,48 @@ int uv_udp_set_multicast_interface(uv_udp_t* handle, const char* interface_addr)
   return 0;
 }
 
-int uv_udp_getpeername(const uv_udp_t* handle,
-                       struct sockaddr* name,
-                       int* namelen) {
+int uv_udp_getpeername(const uv_udp_t *handle,
+                       struct sockaddr *name,
+                       int *namelen)
+{
 
-  return uv__getsockpeername((const uv_handle_t*) handle,
+  return uv__getsockpeername((const uv_handle_t *)handle,
                              getpeername,
                              name,
                              namelen);
 }
 
-int uv_udp_getsockname(const uv_udp_t* handle,
-                       struct sockaddr* name,
-                       int* namelen) {
+int uv_udp_getpeername_ex(const uv_udp_t *handle,
+                          struct sockaddr **name,
+                          int *namelen)
+{
+  *namelen = sizeof(struct sockaddr_storage);
+  *name = (struct sockaddr *)&handle->peer_name;
+  return 0;
+}
+
+int uv_udp_getsockname(const uv_udp_t *handle,
+                       struct sockaddr *name,
+                       int *namelen)
+{
 
-  return uv__getsockpeername((const uv_handle_t*) handle,
+  return uv__getsockpeername((const uv_handle_t *)handle,
                              getsockname,
                              name,
                              namelen);
 }
 
-
-int uv__udp_recv_start(uv_udp_t* handle,
+int uv__udp_recv_start(uv_udp_t *handle,
                        uv_alloc_cb alloc_cb,
-                       uv_udp_recv_cb recv_cb) {
+                       uv_udp_recv_cb recv_cb)
+{
   int err;
 
   if (alloc_cb == NULL || recv_cb == NULL)
     return UV_EINVAL;
 
   if (uv__io_active(&handle->io_watcher, POLLIN))
-    return UV_EALREADY;  /* FIXME(bnoordhuis) Should be UV_EBUSY. */
+    return UV_EALREADY; /* FIXME(bnoordhuis) Should be UV_EBUSY. */
 
   err = uv__udp_maybe_deferred_bind(handle, AF_INET, 0);
   if (err)
@@ -1389,8 +1533,8 @@ int uv__udp_recv_start(uv_udp_t* handle,
   return 0;
 }
 
-
-int uv__udp_recv_stop(uv_udp_t* handle) {
+int uv__udp_recv_stop(uv_udp_t *handle)
+{
   uv__io_stop(handle->loop, &handle->io_watcher, POLLIN);
 
   if (!uv__io_active(&handle->io_watcher, POLLOUT))
